#!/usr/bin/env bash
#
# Run `kubectl get` on all the contexts found in your `.kube/config`.

[[ -n $DEBUG ]] && set -x

set -eou pipefail
IFS=$'\n\t'

usage() {
  local SELF
  SELF="kubectl-all"
  if [[ "$(basename "$0")" == kubectl-* ]]; then # invoked as plugin
    SELF="kubectl all"
  fi

  cat <<EOF
USAGE:
  $SELF get [(-o|--output=)json|yaml|wide|custom-columns=...|custom-columns-file=...|go-template=...|go-template-file=...|jsonpath=...|jsonpath-file=...] (--like name) (TYPE[.VERSION][.GROUP] [NAME | -l label] | TYPE[.VERSION][.GROUP]/NAME ...) [flags] [options]
EOF
}

exit_err() {
   echo >&2 "${1}"
   exit 1
}

get_contexts() {
  $KUBECTL config get-contexts -o=name | sort -n
}

main() {
  if hash kubectl 2>/dev/null; then
    KUBECTL=kubectl
  elif hash kubectl.exe 2>/dev/null; then
    KUBECTL=kubectl.exe
  else
    exit_err "kubectl is not installed"
  fi

  if [[ "$#" -eq 0 ]]; then
    usage
    exit 1
  fi

  # allow only the 'get' command
  if [[ "${@#get}" = "$@" ]]; then
    exit_err "get is the only command supported"
  fi

  ARGS=${@:1}
  NAME=''

  # check '--like' flag
  while [[ $# -gt 0 ]]
  do
    case $1 in
      --like) NAME=$2
        shift;shift ;;
      *)
        shift;;
  esac
  done

  # remove '--like' flag and its value from args
  if [[ -n $NAME ]]; then
    ARGS="${ARGS//--like $NAME}"
  fi

  # reconstruct args
  ARGS=( $(xargs -n 1 <<<"$ARGS") )

  # run provided kubectl command for all the contexts
  for context in $(get_contexts)
  do
    tput setaf 1
    echo -e "\nContext: $context"
    tput sgr0
    if [[ -n $NAME ]]; then
      $KUBECTL --context=$context ${ARGS[@]} | grep $NAME || [[ $? == 1 ]]
    else
      $KUBECTL --context=$context ${ARGS[@]} || [[ $? == 1 ]]
    fi
  done
}

main "$@"